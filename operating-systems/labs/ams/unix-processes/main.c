/*
For each command line argument the main process will launch a subprocess (type A).
The A process will try to execute, in a new subprocess (type B), using one of the
exec functions, the received argument.
In case of failure, the process of type A, will send to his parent, using a pipe
channel, the error code (errno value) generated by the exec call.
On success, the process A, will wait for process of type B and once finished it 
will transmit to his parent the zero code, using the same pipe channel.
The main process will print for each argument if the execution was successful or
not. Only for failed executions the error received code will be printed too.
*/

#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#include <fcntl.h>
#include <stdlib.h>
#include <errno.h>
#include <assert.h>

#define DEBUG_MODE 0
#define debug_puts(_debug_s)    \
    if(DEBUG_MODE)              \
    {                           \
        printf("DEBUG: ");      \
        puts(_debug_s);         \
    }
#define debug_printf(_debug_format, _debug_printf_args...)  \
    if(DEBUG_MODE)                                          \
    {                                                       \
        printf("DEBUG: ");                                  \
        printf(_debug_format, _debug_printf_args);          \
    }

#define R 0
#define W 1

int main(int argc, char *argv[])
{
    if(argc == 1)
    {
        printf("Usage: %s command1 command2 ... commandN\n", argv[0]);
        exit(EXIT_FAILURE);
    }

    int p2worker[2], i;
    if(pipe(p2worker) == -1)
    {
        perror("pipe");
        exit(EXIT_FAILURE);
    }

    for(i = 1; i < argc; i++)
    {
        debug_printf("Executing command '%s'\n", argv[i]);
        
        pid_t worker = fork();
        if(worker == -1)
        {
            perror("fork worker");
            exit(EXIT_FAILURE);
        }
        
        // worker process
        if(worker == 0)
        {
            debug_puts("worker process"); 
            //close(p2worker[R]); // close read
            
            pid_t exec_proc = fork();
            if(exec_proc == -1)
            {
                perror("fork exec process");
                exit(EXIT_FAILURE);
            }

            // exec process
            if(exec_proc == 0)
            {
                debug_puts("worker exec process");

                // parse argument
                int command_len = 1024, j = 0;
                char *command[command_len], *p;
                p = strtok(argv[i], " ");
                while(p != NULL)
                {
                    // copy
                    assert(j < command_len);
                    command[j] = p;
                    j++;
                    
                    // get next 
                    p = strtok(NULL, " ");
                }

                int status = execvp(command[0], command);
                
                // error on exec
                if(status == -1)
                {
                    exit(errno);
                }

                exit(EXIT_SUCCESS);
            } // if exec process

            // worker process
            int exec_proc_status;
            int exit_status;
            waitpid(exec_proc, &exec_proc_status, 0); // wait for exec
            
            exit_status = WEXITSTATUS(exec_proc_status);
            debug_printf("Exec process exited with status=%d and errno=%d\n", exec_proc_status, exit_status);
            
            write(p2worker[W], &exit_status, sizeof(int));
            //close(p2worker[W]);

            exit(EXIT_SUCCESS);
        } // if worker process

        // parent process
        debug_puts("parent process");
        //close(p2worker[W]); // close write

        // read from worker
        int status; 
        //while(read(p2worker[R], &status, sizeof(int)) == 0) {};
        read(p2worker[R], &status, sizeof(int));

        debug_printf("Returned to parent %d\n", status);

         // give feedback to user
        if(status == 0)
        {
            printf("Command '%s' executed succesfully\n", argv[i]);
        }
        else
        {
            printf("Command '%s' failed with errno=%d\n", argv[i], status);
            errno = status;
            perror("");
        }

        // wait for worker
        int worker_status;
        waitpid(worker, &worker_status, 0);

        puts("");
    } // for(i = 1; i < argc; i++)
    
    return 0;
}
